# 语句

第4章把JavaScript中的表达式称作短语。那语句就是JavaScript中的句子或命令。就像英语句子用句点来结尾和分隔一样，JavaScript语句以分号（参见2.6节）结尾。表达式被求值后产生一个值，而语句在被执行后会导致某事件发生。

一种“导致某事件发生”的方式是求值一个有副效应的表达式。像赋值或函数调用这样有副效应的表达式本身就可以作为语句，在像这样使用时就被称为表达式语句。另一种与之类似的语句是声明语句，用于声明变量和定义新函数。

JavaScript程序就是一系列待执行的语句。默认情况下，JavaScript解释器按照它们在源代码中的顺序逐个执行这些语句。另一种“导致某事件发生”的方式是改变这个默认的执行顺序，为此，JavaScript提供了一些语句或者叫控制结构。

**条件**

像if和switch这样的语句让JavaScript解释器根据某个表达式的值选择执行或跳过其他语句。

**循环**

像while和for这样的语句会重复执行其他语句。

**跳转**

像break、return和throw这样的语句会导致解释器跳转到程序的其他部分。

本章各节将依次介绍JavaScript中的各种语句，以及它们的语法。本章末尾的表5-1总结了这些语法。JavaScript程序就是一系列语句，以分号作为分隔符。因此只要熟悉JavaScript的语句，就可以上手写JavaScript程序。

## 1 表达式语句

JavaScript 中最简单的一种语句就是有副效应的表达式。这种语句在第4章已经展示过了。赋值语句是一种主要的表达式语句。例如：

```js
greeting = "Hello " + name;
i *= 3;
```

递增操作符++和递减操作符--都跟赋值语句有关。它们都有修改变量值的副效应，就好像执行了赋值语句一样：

```js
counter++;
```

delete操作符有删除对象属性的重要副效应。因此，一般都把它作为一个语句使用，而不是放在某个大的表达式中：

```js
delete o.x;
```

函数调用是另一类主要的表达式语句。例如：

```js
console.log(debugMessage);
displaySpinner(); // 一个假想的函数，会在网页中显示旋转动图
```

这些函数调用都是表达式，但它们有影响宿主环境或程序状态的副效应，因此在这里作为语句使用。如果是没有副效应的函数，那像这样调用就没有什么意义了，除非它在一个更大的表达式中，或者在赋值语句中。例如，谁也不会像这样计算一次余弦，然后丢掉结果：

```js
Math.cos(x);
```

但很可能计算这个值之后把它赋给一个变量，以便将来使用：

```js
cx = Math.cos(x);
```

注意，这些例子中的每行代码都以分号结尾。

## 2 复合语句与空语句

与逗号操作符（参见4.13.7节）将多个表达式组合为一个表达式一样，语句块将多个语句组合为一个复合语句。语句块其实就是一系列语句，可以放在任何期待一个语句的地方：

```js
{
    x = Math.PI;
    cx = Math.cos(x);
    console.log("cos(Π) = " + cx);
}
```

关于这个语句块，我们需要说明几点。第一，它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。第二，块中的代码相对于包含它们的花括号缩进。这不是必需的，但可以让代码更清晰易读。

就像表达式经常会包含子表达式，很多JavaScript语句也包含子语句。例如，while循环语法只包含一个作为循环体的语句。而使用语句块，可以在这个唯一的子语句中添加任意多个语句。

复合语句允许我们在JavaScript语法期待一个语句时使用多个语句。空语句正好相反，它让我们在期待一条语句的地方不包含任何语句。空语句是这样的：

```js
;
```

JavaScript解释器在执行空语句时什么也不会做。空语句偶尔会有用，比如创建一个空循环体的循环。比如下面的for循环（for循环将在5.4.3节介绍)：

```js
// 初始化一个数组a
for (let i = 0; i < a.length; a[i++] = 0) ;
```

在这个循环中，所有工作都是通过表达式a[i++]=0完成的，不需要循环体。但JavaScript语法要求有一条语句作为循环体，此时空语句（就一个分号）可以派上用场。

注意，意外地在for、while循环或if语句的右括号后面加上分号会导致难以发现的隐患。例如，下面的代码可能并不是作者想要的：

```js
if ((a === 0) || (b === 0)); // 这行什么也不做
	o = null;                // 而这行始终都会执行
```

如果你有意使用空语句，最好通过注释说明一下你的用意。比如：

```js
for (let i = 0; i < a.length; a[i++] = 0)
```

## 3 条件语句

条件语句根据指定表达式的值执行或跳过执行某些语句，因此条件语句是代码中需要决策的地方，有时候也被称为“分支”。想象一下，JavaScript解释器沿一条路径执行代码，条件语句表示代码要分成两条或更多条路径，而解释器必须选择其中一条。

接下来几节介绍JavaScript的基本条件语句if/else，以及较复杂的switch多分支语句。

### 3.1 `if`

if语句是最基本的控制语句，可以让JavaScript做出决策，更精确地说，是有条件地执行语句。这个语句有两种形式，第一种是：

```js
if (expression)
    statement
```

在这个形式中，expression（表达式）会被求值。如果结果值是真值，statement（语句）会执行；如果表达式是假值，语句不会执行（参见3.4节中关于真值和假值的定义）。例如：

```js
if (username == null)           // 如果username是null或undefined，
    username = "John Doe";      // 定义这个变量
```

或类似地：

```js
// 如果username是null、undefined、false、θ、""或NaN，给它一个新值
if (!username) username = "John Doe";
```

注意，表达式两边的圆括号是if语句的语法必需的。

JavaScript语法要求在if关键字和带括号的表达式后面必须只跟一个语句，但我们可以使用语句块把多个语句组合成一个语句。因此if语句也可以是类似这样的：

```js
if (!address) {
    address = "";
    message = "Please specify a mailing address.";
}
```

if语句的第二种形式会包含一个else子句，会在表达式为false 时执行。其语法为：

```js
if (expression)
    statement1
else
    statement2
```

这种形式在表达式为真值时执行语句1，在表达式为假值时执行语句2。例如：

```js
if (n === 1)
    console.log("You have 1 new message.");
else
    console.log(`You have ${n} new messages.`);
```

如果在嵌套的if语句中包含else子句，那么就要留心让else子句与相应的if语句对应。来看下面这个例子：

```js
i = j = 1;
k = 2;
if (i === j)
    if (j === k)
        console.log("i equals k");
else
    console.log("i doesn't equal j");  // 错了！
```

在这个例子中，内部的if语句构成了外部if语句语法所需的那条语句。而else语句对应哪个if并不清楚（除了缩进有所暗示之外）。但在这个例子中，缩进是错误的，因为JavaScript解释器实际上会把前面的例子解释为：

```js
if (i === j) {
   if (j === k)
        console.log("i equals k");
   else
   		console.log("i doesn't equal j");  // 我晕！
}
```

JavaScript的规则（与多数编程语言一样）是，默认情况下else子句属于最近的if语句。为了让这个例子更清晰、易读、易理解、易维护、易调试，应该使用花括号：

```js
if (i === j) {
   if (j === k) {
        console.log("i equals k");
   }
} else {
   console.log("i doesn't equal j");
}
```

很多程序员都有使用花括号包装if和else语句（以及其他复合语句，如while循环)的习惯，即使语句体只有一个语句。始终这么做可以避免刚才的问题，建议读者也这么做。在本书中，我始终在设法减少代码行数，因此不一定处处遵循这个建议。

### 3.2 `else if`

if/else语句求值一个表达式并根据结果执行两段代码中的一段。但如果你想执行多段代码中的一段呢？一种思路是使用else if语句。else if并不是真正的JavaScript语句，而是一个在使用if/else时被频繁用到的编程惯例：

```js
if (n === 1) {
   // 执行第一个代码块
} else if (n === 2) {
    //执行第二个代码块
} else if (n === 3) {
    //执行第三个代码块
} else {
    //如果前面都失败，执行第四个代码块
}
```

这段代码没有什么特别的，就是一系列if语句，每个if语句后面都有一个else子句。使用else if更好，也更容易理解，不推荐使用下面这样的完整嵌套形式：

```js
if (n === 1) {
    // 执行第一个代码块
}
else {
    if (n === 2) {
        // 执行第二个代码块
    }
    else {
        if (n === 3) {
            // 执行第三个代码块
        }
        else {
            // 如果前面都失败，执行第四个代码块
        }
    }
}
```

### 3.3 `switch`

if语句在程序执行流中会创建一个分支，而使用多个else if可以实现多个分支。但是，在所有分析都依赖同一个表达式的值时这并不是最好的办法。因为多个if语句重复对一个表达式进行求值太浪费了。

此时最合适的语句是switch语句。switch关键字后面跟着一个带括号的表达式和一个包含在花括号中的代码块：

```js
switch (expression) {
        statements
}
```

不过，switch语句的完整语法比这里展示的要复杂得多。比如，其中代码块的不同位置会有case关键字开头的标签，后跟一个表达式和一个冒号。当switch执行时，它会计算表达式的值，然后对比case标签，看哪个表达式会求值为相同的值（这时的相同意味着===操作符返回true）。如果找到了相同的值，则执行相应case语句的代码块。如果没有找到，则再找标签为default：的语句。如果没有default：标签，switch语句就跳过整个代码块。

switch语句不太好用文字来解释，看个例子更容易明白。下面这个switch语句与前面多个if/else语句的例子是等价的：

```js
switch (n) {
    case 1:         // 如果n===1，从这里开始执行
        // 执行第一个代码块
        break;  // 到这里停止
    case 2:         // 如果n===2，从这里开始执行
        // 执行第二个代码块
        break;
    case 3:
        //执行第三个代码块
        break;
    default:
        // 执行第四个代码块
        break;
}
```

注意代码中每个case末尾的break关键字。这个break语句（本章后面会介绍）将导致解释器跳到switch语句末尾（或“跑出”switch语句），继续执行后面的语句。switch语句中的case子句只指定了预期代码的起点，并没有指定终点。在没有break语句的情况下，switch语句从匹配其表达式值的case代码块开始执行，一直执行到代码块结束。这种情况偶尔是有用的，比如让代码执行流从某个case标签直接“穿透”到下一个case标签。但 99%的时候还是需要注意用break语句来结束每个case（不过在函数中使用switch时，可以使用return语句而非break语句。这两个关键字都可以终止switch语句，阻止执行流进人下一个case）。

下面看一个关于switch语句的更实际的例子，这个switch语句会根据值的类型决定怎么把它转换成字符串：

```js
function convert(x) {
    switch(typeof x) {
        case "number":
            return x.toString(16);
        case "string":
            return '"' + x + '"';
        default:
            return String(x);
    }
}
```

注意在前面两个例子中，case关键字后面分别是数值和字符串字面量。这是实践中使用switch语句的常见方式，但要注意ECMAScript标准允许每个case后面跟任意表达式。

switch语句首先对跟在switch关键字后面的表达式求值，然后再按照顺序求值case表达式，直至遇到匹配的值。这里的匹配使用`===`全等操作符，而不是`==`相等操作符，因此表达式必须在没有类型转换的情况下匹配。

考虑到在switch语句执行时，并不是所有case表达式都会被求值，所以应该避免使用包含副效应的case表达式，比如函数调用或赋值表达式。最可靠的做法是在case后面只写常量表达式。

正如前面解释的，如果没有与switch表达式匹配的case表达式，则switch语句就会执行标签为default：的语句。如果没有default：标签，switch语句会跳过自己的代码体。注意在前面的例子中，default：标签出现在 switch体的末尾，在所有case标签后面。这个位置是符合逻辑的，也是它最常出现的位置。但事实上，default：标签可以出现在switch语句体的任何位置。

## 4 循环语句

为理解条件语句，我们曾想象JavaScript解释器在源代码中会经过不同路径。而循环语句则是把这些路径弯曲又折回起点，以重复执行代码中的某些部分。JavaScript有5种循环语句：while、do/while、for、for/of（及其变体for/await）和for/in。接下来几节将分别介绍这5种循环。循环的一个常见用途是选代数组元素。7.6节详细讨论了这种循环，并介绍了Array类定义的特殊循环方法。

### 4.1 `while`

就像if语句是JavaScript的基本条件控制语句一样，while语句是JavaScript的基本循环语句，具有如下语法：

```js
while (expression)
    statement
```

执行while语句时，解释器首先会求值表达式。如果这个表达式的值是假值，则解释器会跳过作为循环体的语句，继续执行程序中的下一条语句。而如果表达式是真值，则解释器会执行语句并且重复，即跳回循环的开头再次求值表达式。另一种解释方式是，解释器会在表达式为真值时重复执行语句。注意，使用while（true）可以创造一个无穷循环。

通常我们都不希望JavaScript反复执行同样的操作。几乎在每次循环或迭代中，都会有一个或多个变量改变。因为有变量改变，所以执行语句的动作每次循环都可能不同。另外，如果改变的变量会影响表达式，则每次循环这个表达式的值也可能不同。这一点非常重要，否则求值为真值的表达式可能永远不会变，循环也就永远不会结束！下面是一个通过while循环打印数值0到9的例子：

```js
let count = 0;
while (count < 10) {
    console.log(count);
    count++;
}
```

在这个例子中，变量count从0开始，每运行一次循环体count就递增一次。当循环执行10次后，表达式的值变成false（即变量count不再小于10），于是while循环完成，解释器又继续执行程序中的下一条语句。很多循环都有类似count的计数器变量。i、j、k是最常见的循环计数器变量名，当然如果希望让代码更容易理解，还应该使用更具有描述性的名字。

### 4.2 `do/while`

do/while循环与while循环类似，区别是对循环表达式的测试在循环底部而不是顶部。这意味着循环体始终会至少执行一次。语法如下：

```js
do
    statement
while (expression);
```

do/while循环的使用没有while那么频繁，因为实践中很少有需要至少执行一次循环的情况。下面是一个do/while循环的例子：

```js
function printArray(a) {
    let len = a.length, i = 0;
    if (len === 0) {
        console.log("Empty Array");
    } else {
        do {
            console.log(a[i]);
        } while (++i < len);
    }
}
```

从语法上看，do/while循环与while循环有两个区别。首先，do循环要求使用两个关键字：do（标记循环开始）和while（标记循环结束并引l入循环条件）。其次，do循环必须始终以分号终止。而while循环在循环体使用花括号时不需要分号。

### 4.3 `for`

for语句提供了比while语句更方便的循环结构。for语句简化了遵循常见模式的循环。多数循环都有某种形式的计数器变量，这个变量在循环开始前会被初始化，然后循环的每次迭代都会测试它的值。另外，计数器变量在循环体结束时、在被再次测试之前会递增或者更新。在这种循环模式下，初始化、测试和更新是对循环变量的三个关键操作。for语句将这三个操作分别设定为一个表达式，让这些表达式成为循环语法中明确的部分：

```js
for (initialize; test; increment)
    statement
```

initialize、test和increment是三个表达式（以分号隔开），分别负责初始化、测试和递增循环变量。把它们都放在循环的第一行让人更容易理解for循环在做什么，避免忘记初始化或递增循环变量。

解释for循环的最简单方式是对比等价的 while循环：

```js
initialize
while (test) {
    statement
    increment;
}
```

换句话说，initialize表达式只在循环开始前求值一次。为了起作用，这个表达式必须有副效应（通常是赋值）。JavaScript也允许initialize是变量声明语句，以便可以同时声明并初始化循环计数器。test表达式会在每次迭代时求值，用于控制是否执行循环体。如果test求值为真值，则作为循环体的statement就执行。执行后求值increment表达式。同样，increment必须是有副效应的表达式（这样才有作用）；一般来说，要么是赋值表达式，要么使用++或--操作符。

可以使用for循环像下面这样打印数值从0到9，对照一下上一节完成同样操作的while循环：

```js
for (let count = 0; count < 10; count++) {
    console.log(count);
}
```

当然，肯定有比这复杂得多的循环，而且有时候每次迭代要改变的循环变量还不止一个。这种情况是JavaScript中的逗号操作符常见的唯一用武之地。因为逗号操作符可以把多个初始化和递增表达式组合成一个表达式，从而满足for循环的语法要求：

```js
let i, j, sum = 0;
for (i = 0, j = 10; i < 10; i++, j--) {
    sum += i * j;
}
```

目前为止，所有循环示例中的循环变量都是数值。这种情况常见但不是必需的。以下代码使用for循环遍历了一个链表数据结构，返回了列表中的最后一个对象（即第一个没有next属性的对象)：

```js
function tail(o) {
    for (; o.next; o = o.next);
    return o;
}
```

注意，这段代码中没有initialize表达式。对for循环而言，三个表达式中任何一个都可以省略，只有两个分号是必需的。如果省略了test表达式，循环会永远重复执行。因此for（；；）与while（true）一样，是另一种编写无穷循环的方式。

### 4.4 `for/of`

ES6定义了一个新循环语句：for/of。这种新循环虽然使用for关键字，但它与常规for循环是完全不同的两种循环（for/of与5.4.5节要讨论的for/in循环也是完全不同的）。

for/of循环专门用于可迭代对象。第12章会解释到底什么对象是可迭代对象，但现在只要知道数组、字符串、集合和映射都是可迭代的就行了。它们都是一组或一批元素，可以使用for/of循环来循环或迭代这些元素。

例如，下面这个例子演示了如何迭代一个数值数组并计算所有数值之和：

```js
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
for (let element of data) {
    sum += element;
}
sum // => 45
```

表面上看，这个语法跟常规for循环很像，都是for关键字后跟着一对圆括号，其中包含如何循环的细节。具体来说，这里的圆括号中包含一个变量声明（对于已经声明的变量，只包含变量名即可），然后是of关键字和一个求值为可迭代对象的表达式（比如这里的 data 数组）。与所有循环一样，for/of 循环的循环体紧跟在圆括号之后，通常包含在花括号中。

在上面的代码中，循环体对应data数组中的每个元素都会运行一次。在每次执行循环体之前，都会把数组的下一个元素赋值给元素变量。数组元素是按照从头到尾的顺序选代的。

数组迭代是“实时”的，即选代过程中的变化可能影响迭代的输出。如果修改前面的代码，在循环内添加一行data.push(sum)；，则会创建一个无穷循环。因为迭代永远不会触及数组的最后一个元素。

**for/of 与对象**

对象（默认）是不可迭代的。运行时尝试对常规对象使用for/of会抛出TypeError:

```js
let o = {x: 1, y: 2, z: 3 };
for (let element of o) { // 抛出TypeError，因为o不是可迭代对象
    console.log(element); 
}
```

如果想迭代对象的属性，可以使用for/in循环（见5.4.5节)，或者基于0bject.keys（)方法的结果使用for/of：

```js
let o = {x: 1, y: 2, z: 3 };
let keys = "";
for (let k of Object.keys(o)) {
    keys += k;
}
keys // => "xyz"
```

这是因为Object.keys（）返回一个对象属性名的数组，而数组是可以通过for/of来迭代的。也要注意，这种对象的键的迭代并不像上面例子那样是实时的，在循环体内修改对象。不会影响迭代。如果你不在乎对象的键，也可以像下面这样迭代每个键对应的值：

```js
let sum = 0;
for (let v of Object.values(o)) {
    sum += v;
}
sum // => 6
```

如果你既想要对象属性的键，也想要属性的值，可以基于`Object.entries()`和解构赋值来使用for/of：

```js
let pairs = "";
for (let [k, v] of Object.entries(o)) {
    pairs += k + v;
}
pairs // => "x1y2z3"
```

`Object.entries()`返回一个数组的数组，其中每个内部数组表示对象的一个属性的键值对。这里使用解构赋值把这些内部数组拆开，并将它们的元素赋值给两个变量。

**for/of与字符串**

字符串在ES6中是可以逐个字符迭代的：

```js
let frequency = {};
for (let letter of "mississippi") {
    if (frequency[letter]) {
        frequency[letter]++;
    } else {
        frequency[letter] = 1;
    }
}
frequency // => {m:1,i:4, s:4,p:2}
```

注意，字符串是按照Unicode码点而不是UTF-16字符迭代的。字符串`"I❤️🐕"`的`length`是5（因为两个表情符号分别需要两个UTF-16字符表示）。但如果使用for/of来迭代这个字符串，循环体将运行3次，每次迭代一个码点。

**for/of与Set和Map**

ES6内置的Set（集合）和Map（映射）类是可迭代的。在使用for/of迭代Set时，循环体对集合中的每个元素都会运行一次。可以使用类似下面的代码打印出一个文本字符串中的唯一单词：

```js
let text = "Na na na na na na na na Batman!";
let wordSet = new Set(text.split(" "));
let unique = [];
for (let word of wordSet) {
    unique.push(word);
}
unique // => ["Na", "na", "Batman!"]
```

Map则比较有意思，因为Map对象的选代器并不迭代Map键或Map值，而是迭代键/值对。每次迭代，迭代器都会返回一个数组，其第一个元素是键，第二个元素是对应的值。给出一个Map m，可以像下面这样迭代和解构其键/值对：

```js
let m = new Map([[1, "one"]]);
for (let [key, value] of m) {
    key // => 1
    value // => "one"
}
```

**for/await与异步迭代**

ES2018新增了一种新迭代器，称为异步迭代器，同时新增了一种for/of循环，即使用异步迭代器的for/await循环。

要理解for/await循环，可能需要阅读第12章和第13章，但这里可以先看一看它的代码示例：

```js
//从异步可选代流中读取数据块并将其打印出来
async function printStream(stream) {
    for await (let chunk of stream) {
        console.log(chunk);
    }
}
```

### 4.5 `for/in`

for/in循环看起来很像for/of循环，只不过of关键字换成了in。与for/of循环要求of后面必须是可迭代对象不同，for/in循环的in后面可以是任意对象。for/of循环是ES6新增的，而for/in是JavaScript从一开始就有的（这也是为什么它的语法显得更自然的原因）。

for/in语句循环指定对象的属性名，语法类似如下所示：

```js
for (variable in object)
    statement
```

variable通常是一个变量名，但也可能是变量声明或任何可以作为赋值表达式左值的东西。object是一个求值为对象的表达式。跟以前一样，statement是作为循环体的语句或语句块。

比如，可以这样使用for/in循环：

```js
for (let p in o) {        // 将o的属性名赋值给变量p
    console.log(o[p]);    // 打印每个属性的值
}
```

执行for/in语句时，JavaScript解释器首先求值object表达式。如果它求值为null 或undefined，解释器会跳过循环并转移到下一个语句。否则，解释器会对每个可枚举的对象属性执行一次循环体。但在每次迭代前，解释器都会求值variable表达式，并将属性名字（字符串值）赋值给它。

注意，for/in循环中的variable可能是任意表达式，只要能求值为赋值表达式的左值就可以。这个表达式在每次循环时都会被求值，这意味着每次的求值结果可能都不同。比如，可以用类似下面的代码把一个对象的所有属性复制到数组中：

```js
let o = {x: 1, y: 2, z: 3 };
let a = [], i = 0;
for(a[i++] in o)/* 空循环体 */;
```

JavaScript数组其实就是一种特殊的对象，而数组索引是对象的属性，可以通过for/in循环来枚举。例如，在前面的代码后面再执行下面这行代码，会枚举出数组索引0、1、2：

```js
for (let i in a) console.log(i);
```

我自己在写代码时，常常因为本来应该对数组使用for/of却意外使用了for/in而导致隐错（bug）。在操作数组时，基本上只会用到for/of 而不是for/in。

for/in循环并不会枚举对象的所有属性，比如它不会枚举名字为符号的属性。而对于名字为字符串的属性，它只会遍历可枚举的属性（参见14.1节）。JavaScript核心定义的各种内部方法是不可枚举的。比如，所有对象都有toString（）方法，但for/in循环不会枚举toString属性。除了内部方法，内部对象的不少其他属性也是不可枚举的。默认情况下，我们手写代码定义的所有属性和方法都是可枚举的（可以使用14.1节介绍的技术让它们不可枚举）。

继承的可枚举属性（参见6.3.2节）也可以被for/in循环枚举。这意味着如果你使用for/in循环，并且代码中会定义被所有对象继承的属性，那你的循环就有可能出现意外结果。为此，很多程序员更愿意基于object.keys（）使用for/of循环，而不是使用for/in循环。

如果for/in循环的循环体删除一个尚未被枚举的属性，则该属性就不会再被枚举了。如果循环体在对象上又定义了新属性，则新属性可能会（也可能不会）被枚举。关于for/in枚举对象属性的顺序，可以参见6.6.1节。