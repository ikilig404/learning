# 类型、值和变量

计算机程序通过操作值（如数值3.14）或文本（如“HelloWorld”）来工作。编程语言中这些可以表示和操作的值被称为类型，而一门语言支持的类型集也是这门语言最基本的特征。程序在需要把某个值保存下来以便将来使用时，会把这个值赋给（或存人）变量。变量有名字，程序可以通过这些名字来引用值。变量的工作方式则是一门编程语言的另一个基本特征。本章讲解JavaScript中的类型、值和变量。首先从概念和一些定义开始。

## 1 概述与定义

JavaScript 类型可以分为两类：原始类型和对象类型。JavaScript 的原始类型包括数值、文本字符串（也称字符串）和布尔真值（也称布尔值）。本章将用很大篇幅专门详细讲解 JavaScript 中的数值（见3.2节）类型和字符串（见3.3节）类型。布尔值将在3.4节介绍。

JavaScript 中的特殊值`null`和`undefined`也是原始值，但它们不是数值、字符串或布尔值。这两个值通常被认为是各自特殊类型的唯一成员，将在3.5节进行介绍。ES6新增了一种特殊类型`Symbol`（符号)，用于对语言进行扩展而不破坏向后兼容性。3.6节将简单介绍符号。

在 JavaScript 中，任何不是数值、字符串、布尔值、符号、`null`和`undefined`的值都是对象。对象（也就是对象类型的成员）是属性的集合，其中每个属性都有一个名字和一个值（原始值或其他对象）。有一个非常特殊的对象叫全局对象，将在3.7节介绍。但关于对象更通用也更详尽的介绍会放在第6章。

普通 JavaScript 对象是一个命名值的无序集合。这门语言本身也定义一种特殊对象，称为数组。数组表示一个数字值的有序集合。JavaScript 语言包括操作数组的特殊语法，而数组本身也具有区别于普通对象的行为。数组是第7章的主题。

除了基本的对象和数组之外，JavaScript 还定义了其他一些有用的对象类型。`Set`对象表示一组值的集合，`Map`对象表示键与值的映射。各种“定型数组”（`typed array`）类型便于对字节数组和其他二进制数据进行操作。`RegExp`类型表示文本模式，可以实现对字符串的复杂匹配、搜索和替换操作。`Date`类型表示日期和时间，支持基本的日期计算。`Error`及其子类型表示 JavaScript 代码运行期间可能发生的错误。所有这些类型将在第11章介绍。

JavaScript 与静态语言更大的差别在于，函数和类不仅仅是语言的语法，它们本身就是可以被JavaScript 程序操作的值。与其他 JavaScript 非原始值一样，函数和类也是特殊的对象。第8章和第9章将详细介绍它们。

在内存管理方面，JavaScript 解释器会执行自动垃圾收集。这意味着 JavaScript 程序员通常不用关心对象或其他值的析构与释放。当一个值无法触达时，或者说当程序无法以任何方式引用这个值时，解释器就知道这个值已经用不到了，会自动释放它占用的内存（JavaScript 程序员有时候需要留意，不能让某些值在不经意间存续过长时间后仍可触达，从而导致它们无法被回收）。

JavaScript 支持面向对象的编程风格。粗略地说，这意味着不用定义全局函数去操作不同类型的值，而是由这些类型本身定义操作值的方法。比如要对数组元素排序，不用把数组传给一个`sort()`函数，而是可以调用数组`a`的`sort()`方法：

```js
a.sort()  // sort(a)的面向对象版
```

第 9 章将介绍如何定义方法。从技术角度来讲，只有 JavaScript 对象才有方法。但数值、字符串、布尔值和符号表现得似乎它们也有方法。在 JavaScript 中，只有`null`和`undefined`是不能调用方法的值。

JavaScript 的对象类型是可修改的（`mutable`)，而它的原始类型是不可修改的（`immutable`）。可修改类型的值可以改变，比如 JavaScript 程序可以修改对象属性和数组元素的值。数值、布尔值、符号、`null`和`undefined`是不可修改的，以数值为例，修改它是没有意义的。字符串可以看成字符数组，你可能期望它们是可修改的。但在 JavaScript 中，字符串也是不可修改的。虽然可以按索引访问字符串中的字符，但 JavaScript 没有提供任何方式去修改已有字符串的字符。可修改值与不可修改值的区别将在 3.8 节更详细地介绍。

JavaScript 可以自由地转换不同类型的值。比如，程序期待一个字符串，而你提供了一个数值，这个数值会自动转换为字符串。而如果你在一个期待布尔值的地方使用了非布尔值，JavaScript也会相应地把它转换为布尔值。这种自动转换的规则将在 3.9 节解释。

JavaScript 这种自由的值转换会影响对相等的定义，而相等操作符`==`会根据 3.9.1 节的描述进行类型转换（不过在实践中，相等操作符`==`已经被弃用，取而代之的是不会做类型转换的严格相等操作符`===`。关于这两个操作符的更多介绍可以参见 4.9.1 节）。

常量和变量可以让我们在程序中使用名字来引用值。常量使用`const`声明，变量使用`let`（或在较老的 JavaScript 代码中使用`var`）声明。JavaScript 常量和变量是无类型的(`untyped`)，声明并不会限定要赋何种类型的值。变量声明和赋值将在3.10节介绍。

看完以上概述，想必读者也已经心领神会了。这一章内容非常宽泛，涉及 JavaScript 如何表示和操作数据的很多基础性细节。下面我们就从详尽了解 JavaScript 数值和文本开始。

## 2 数值

JavaScript 的主要数值类型`Number`用于表示整数和近似实数。JavaScript使用`IEEE754`标准定义的64 位浮点格式表示数值，这意味着 JavaScript 可以表示的最大整数是$\pm 1.797\,693\,134\,862\,315\,7 \times 10^{308}$，最小整数是$\pm 5 \times 10^{-324}$。

JavaScript 的这种数值格式可以让我们准确表示$-9\,007\,199\,254\,740\,992(-2^{53})$到$9\,007\,199\,254\,740\,992(2^{53})$之间的所有整数（含首尾值）。如果你的数值超出了这个范围，那可能会在末尾的数字上损失一些精度。但要注意，JavaScript 中的某些操作（如第4章介绍的数组索引和位操作）是以 32 位整数计算的。如果想准确表示更大的整数，可以参考 3.2.5 节。

当数值真正出现在 JavaScript 程序中时，就叫作数值字面量（numeric literal）。JavaScript 支持几种形式的数值字面量，后面几节会介绍。注意，任何数值字面量前面都可以加上一个减号（`-`）将数值变成负值。

### 2.1 整数字面量

在 JavaScript 程序中，基数为 10 的整数可以直接写成数字序列。例如：

```js
0
3
10000000
```

除了基数为 10 的整数字面量之外，JavaScript 也支持十六进制（基数是 16 的）值。十六进制字面量以`0x`或`0X`开头，后跟一个十六进制数字字符串。十六进制数字是数字 0 到 9 和字母 a（或A）到f（或F）,a 到 f 表示 10 到 15 。下面是十六进制整数字面量的例子：

```js
0xff // => 255:（15*16+15)
0xBADCAFE // => 195939070
```

在 ES6 及之后的版本中，也可以通过二进制（基数为2）或八进制（基数为8）表示整数，分别使用前缀`0b`和`0o`（或`0B`和`0O`)：

```js
0b10101 // =>21:（1*16+0*8+1*4+0*2+1*1)
0o377  // => 255:(3*64+7*8+7*1)
```

### 2.2 浮点字面量

浮点字面量可以包含小数点，它们对实数使用传统语法。实数值由数值的整数部分、小数点和数值的小数部分组成。

浮点字面量也可以使用指数记数法表示，即实数值后面可以跟字母e（或E)，跟一个可选的加号或减号，再跟一个整数指数。这种记数法表示的是实数值乘以10的指数次幂。

更简洁的语法形式为：`[digits][.digits][(E|e)[(+|-)]digits]`

例如：

```js
3.14
2345.6789
.333333333333333333
6.02e23 // 6.02 × 10²³
1.4738223E-32 // 1.4738223×10-³²
```

可以用下划线将数值字面量分隔为容易看清的数字段：

```js
let billion = 1_000_000_000; // 以下划线作为千分位分隔符
let bytes = 0x89_AB_CD_EF;  // 作为字节分隔符
let bits = 0b0001_1101_0111; // 作为半字节分隔符
let fraction = 0.123_456_789; // 也可以用在小数部分
```

在 2020 年年初写作本书时，数值字面量中像这样添加下划线还没有成为正式的 JavaScript 标准。但这个特性已经进入标准化流程的后期，而且已经被所有主流浏览器以及 Node 实现了。

### 2.3 JavaScript中的算术

JavaScript 程序使用语言提供的算术操作符来操作数值，包括表示加法的`+`、表示减法`-`、表示乘法的`*`、表示除法的`/`和表示取模（除法后的余数）的`%`。ES2016增加了取幂的`**`。这些操作符以及更多操作符将在第4章详细介绍。

除了上述基本的算术操作符之外，JavaScript 还通过`Math`对象的属性提供了一组函数和常量，以支持更复杂的数学计算：

```js
Math.pow(2, 53)               // => 9001199254740992: 2的53次方
Math.round(.6)                // => 1.0: 舍入到最接近的整数
Math.ceil(.6)                 // => 1.0: 向上舍入到一个整数
Math.floor(.6)                // => 0.0: 向上舍入到一个整数
Math.abs(-5)                  // => 5：绝对值
Math.max(x, y, z)
Math.min(x, y, z)
Math.random()                  // 伪随机数x，其中 0 <= x 1.0
Math.PI                        // 圆周率
Math.E                         // 自然对数的底数
Math.sqrt(3)                   // 3的平方根
Math.pow(3, 1/3)               // 3的立方根
Math.sin(0)                    // 三角函数 Math.cos ath.atan等
Math.log(10)                   // 10的自然对数
Math.log(100)/Math.LN10        // 以10为底100的对数
Math.log(512)/Math.LN2         // 以2为底512的对数
Math.exp(3)                    // Math.E的立方
```

ES6 在`Math`对象上又定义了一批函数：

```js
Math.cbrt(27)     // 立方根
Math.hypot(3, 4)  // 所有参数平方和的平方根
Math.log10(100)   // 以10为底的对数
Math.log2(1024)   // 以2为底的对数
Math.log1p(x)     // （1+x）的自然对数；精确到非常小的×
Math.expm1(x)     // Math.exp(x)-1；Math.log1p()的逆运算
Math.sign(x)      // 对<、==或>0的参数返回-1、θ或1
Math.imul(2, 3)   // => 6：优化的32位整数乘法
Math.clz32(0xf)   // => 28：32位整数中前导0的位数
Math.trunc(3.9)   // => 3：剪掉分数部分得到整数
Math.fround(x)    // 舍入到最接近的32位浮点数
Math.sinh(x)      // 双曲线正弦，还有 Math.cosh() 和 Math.tanh()
Math.asinh(x)     // 双曲线反正弦，还有 Math.acosh() 和 Math.atanh()
```

JavaScript 中的算术在遇到上溢出、下溢出或被零除时不会发生错误。在数值操作的结果超过最大可表示数值时（上溢出），结果是一个特殊的无穷值`Infinity`。类似地，当某个负数的绝对值超过了最大可表示负数的绝对值时，结果是负无穷值`-Infinity`。这两个无穷值的行为跟我们的预期一样：任何数加、减、乘、除无穷值结果还是无穷值（只是符号可能相反）。

下溢出发生在数值操作的结果比最小可表示数值更接近 0 的情况下。此时，JavaScript 返回0。如果下溢出来自负数，JavaScript返回一个被称为“负零”的特殊值。这个值与常规的零几乎完全无法区分，JavaScript 程序员极少需要检测它。

被零除在 JavaScript 中不是错误，只会简单地返回无穷或负无穷。不过有一个例外：0 除以 0 是没有意义的值，这个操作的结果是一个特殊的“非数值”（`NaN`，Not a Number）。此外，无穷除无穷、负数平方根或者用无法转换为数值的非数值作为算术操作符的操作数，结果也都是NaN。

JavaScript 预定义了全局常量`Infinity`和`NaN`以对应正无穷和非数值。这些值也可以通过`Number`对象的属性获取：

```js
Infinity
Number.POSITIVE_INFINITY
1 / 0
Number.MAX_VALUE * 2
-Infinity
Number.NEGATIVE_INFINITY
-1/0
-Number.MAX_VALUE * 2

NaN
Number.NaN
0/0
Infinity/Infinity

Number.MIN_VALUE/2
-Number.MIN_VALUE/2
-1/Infinity
-0

// ES6定义了下列 Number 属性
Number.parseInt() // 同全局parseInt（）函数
Number.parseFloat() // 同全局parseFLoat(）函数
Number.isNaN(x)  // 判断x是不是NaN
Number.isFinite(x)  // 判断 × 是数值还是无穷
Number.isInteger(x)  // 判断×是不是整数
Number.isSafeInteger(x)
Number.MIN_SAFE_INTEGER // => -(2**53-1)
Number.MAX_SAFE_INTEGER // => 2**53-1
Number.EPSILON // => 2**-52：数值与数值之间最小的差
```

非数值在 JavaScript 中有一个不同寻常的特性：它与任何值比较都不相等，也不等于自己。这意味着不能通过`× === NaN`来确定某个变量`×`的值是`NaN`。相反，此时必须写成`x != x`或`Number.isNaN(x)`。这两个表达式当且仅当×与全局常量NaN具有相同值时才返回true。

全局函数`isNaN()`与`Number.isNaN()`类似。它会在参数是`NaN`时，或者在参数是无法转换为数值的非数值时返回`true`。相关的函数`Number.isFinite()`在参数不是`NaN`、`Infinity`或`-Infinity`时返回true。全局`isFinite()`函数在参数是有限数或者可以转换为有限数时返回true。

负零值也有点不同寻常。它与正零值相等（即便使用JavaScript的严格相等比较)，这意味着除了作为除数使用，几乎无法区分这两个值：

```js
let zero = 0; // 常规的零
let negz = -0; // 负零
zero === negz  // =>true：零等于负零
1/zero === 1/negz // => false：Infinity不等于-Infinity
```

> 在 JavaScript 和许多其他编程语言中，`NaN`（Not-a-Number）不等于自身的设计初衷可以追溯到 IEEE 754 浮点数标准。IEEE 754 是一个为浮点计算定义的国际标准，该标准规定了浮点数的表示方法和操作规则。`NaN` 是 IEEE 754 标准中的一个特殊值，用于表示未定义或不可表示的数值结果。
>
> 以下是 `NaN` 不等于自身这一设计的几个初衷：
>
> 1. **错误传播和检测**：
>    `NaN` 用于表示错误的计算结果，如零除零、无效操作（例如取负数的平方根）等。为了让错误能够被有效地传播和检测，IEEE 754 规定 `NaN` 不等于任何值，包括自身。这样，任何涉及 `NaN` 的比较操作都会产生确定的错误信号，从而提醒开发者进行处理。
>
>    ```javascript
>    let x = 0 / 0; // x is NaN
>    console.log(x === x); // false, indicating x is NaN
>    ```
>
> 2. **不确定性表示**：
>    `NaN` 表示一个不确定或无法定义的数值。将 `NaN` 设计为不等于自身，反映了这种不确定性。它传递了一个明确的信息，即该值不具有确定的数值意义，因此不能进行常规的比较操作。
>
>    ```javascript
>    let y = Math.sqrt(-1); // y is NaN
>    console.log(y !== y); // true, indicating y is NaN
>    ```
>
> 3. **一致性和简化实现**：
>    对于浮点数操作和表示，IEEE 754 标准试图提供一致且简单的规则。规定 `NaN` 不等于自身，简化了硬件和软件实现中的边界情况处理，并确保了不同平台和实现之间的行为一致性。
>
> 4. **帮助调试和错误检测**：
>    通过 `NaN` 不等于自身的特性，可以在调试和错误检测中快速识别 `NaN` 值。开发者可以利用这一特性编写检查函数，来捕捉和处理异常情况。
>
>    ```javascript
>    function checkNaN(value) {
>      return value !== value;
>    }
>       
>    let result = checkNaN(NaN);
>    console.log(result); // true, indicating value is NaN
>    ```
>
> 总之，`NaN` 不等于自身的设计初衷是为了遵循 IEEE 754 标准中的规定，确保浮点数运算中的一致性和简化实现，并提供一种有效的机制来传播和检测计算错误。这一特性在编程实践中提供了一个简洁的方法来识别和处理 `NaN` 值。

### 2.4 二进制浮点数与舍入错误

实数有无限多个，但 JavaScript 的浮点格式只能表示其中有限个（确切地说，是18437736874454810627个）。这意味着在通过 JavaScript 操作实数时，数值表示的经常是实际数值的近似值。

JavaScript（以及所有现代编程语言）使用的 IEEE-754 浮点表示法是一种二进制表示法，这种表示法可以精确地表示如1/2、1/8和1/1024等分数。然而，我们最常用的分数（特别是在进行财务计算时）是十进制分数：1/10、1/100，等等。二进制浮点表示法无法精确表示哪怕0.1这么简单的数。

虽然 JavaScript 数值有足够大的精度，能够非常近似地表示 0.1，但无法精确地表示。这可能导致一些问题。比如以下代码：

```js
let x = .3 - .2; // 30美分减20美分
let y = .2 - .1; // 20美分减10美分
x === y   // => false：这两个值不一样！
x === .1  // => false：.3-.2不等于.1
y === .1  // => true：.2-.1等于.1
```

由于舍入错误，`.3`和`.2`近似值的差与.2和.1近似值的差并不相等。这并不是 JavaScript 独有的问题，而是所有使用二进制浮点数的编程语言共同的问题。同样，也要注意代码中x和y的值极其接近，它们也都极其接近正确的值。这个计算得到的值完全能够满足任何需要，切记不要试图比较它们的相等性。

如果浮点近似值对你的程序而言是个问题，可以考虑使用等量整数。例如，计算与钱数有关的数值时可以使用整数形式的美分，而不是零点几美元。

### 2.5 通过`BigInt`表示任意精度整数

ES2020 为 JavaScript 定义了一种新的数值类型`BigInt`。2020年年初，Chrome、Firefox、Edge和Node都实现了这个类型，Safari也在实现中。顾名思义，`BigInt`这种数值类型的值是整数。之所以增加这个类型，主要是为了表示64位整数，这对于兼容很多其他语言和API是必需的。但`BigInt`值可能有数千甚至数百万个数字，可以满足对大数的需求（不过，BigInt的实现并不适合加密，因为它们没有考虑防止时序攻击）。

> 时序攻击（Timing Attack）是一种侧信道攻击，攻击者通过测量和分析程序执行的时间来推测内部数据，进而获取敏感信息。JavaScript 中的 `BigInt` 可以用来进行高精度的整数运算，但在涉及加密操作时，也需要注意避免时序攻击。
>
> ### 时序攻击的基本原理
>
> 在时序攻击中，攻击者会尝试发现系统响应时间上的微小差异。这些差异可能反映出不同的分支路径或操作，这些路径或操作可能依赖于秘密数据（如密码、加密密钥等）。如果加密算法的执行时间与输入数据有关，攻击者可以通过多次测试，逐步推测出敏感信息。
>
> ### 保护措施
>
> 为了防止时序攻击，通常需要确保加密操作的执行时间不依赖于输入数据，以下是一些防护措施：
>
> 1. **使用恒定时间算法**：确保算法的每一步执行时间相同。
> 2. **避免条件分支**：避免在依赖于密钥或其他敏感数据的条件下使用分支结构（如 `if-else`）。
> 3. **标准库和硬件支持**：使用经过验证的标准加密库和硬件加速支持。
>
> ### BigInt 加密中的防护措施
>
> 在使用 `BigInt` 进行加密操作时，以下是一些避免时序攻击的具体建议：
>
> 1. **恒定时间比较**：
>    - 传统的 `==` 和 `!=` 比较操作可能会泄露信息，因为它们可能在发现不匹配后立即返回。
>    - 需要使用恒定时间的比较函数来确保比较操作不泄露时间信息。
>
> 2. **恒定时间运算**：
>    - 确保所有涉及敏感数据的运算都在恒定时间内完成，避免在数据依赖的情况下产生时间差异。
>
> 3. **避免早期返回**：
>    - 在验证密码或密钥时，不要在发现错误后立即返回。即使数据不匹配，也应该完成所有预定的运算以确保时间一致。
>
> ### 示例代码
>
> 以下是一个示例，展示了如何使用恒定时间的比较函数：
>
> ```javascript
> function constantTimeCompare(a, b) {
>   if (a.length !== b.length) {
>     return false;
>   }
> 
>   let result = 0;
>   for (let i = 0; i < a.length; i++) {
>     result |= a.charCodeAt(i) ^ b.charCodeAt(i);
>   }
> 
>   return result === 0;
> }
> 
> // 示例：比较两个 BigInt 值的字符串表示是否相同
> let bigInt1 = BigInt("1234567890123456789012345678901234567890");
> let bigInt2 = BigInt("1234567890123456789012345678901234567890");
> 
> let str1 = bigInt1.toString();
> let str2 = bigInt2.toString();
> 
> console.log(constantTimeCompare(str1, str2)); // true
> ```
>
> ### 恒定时间加密操作示例
>
> 如果你在使用 `BigInt` 进行加密运算时，确保所有操作都在恒定时间内完成：
>
> ```javascript
> function constantTimeModExp(base, exp, mod) {
>   let result = BigInt(1);
>   let b = base % mod;
>   let e = exp;
> 
>   while (e > 0) {
>     if (e % BigInt(2) === BigInt(1)) {
>       result = (result * b) % mod;
>     }
>     b = (b * b) % mod;
>     e = e / BigInt(2);
>   }
> 
>   return result;
> }
> 
> // 示例：使用 BigInt 进行模幂运算
> let base = BigInt("1234567890123456789012345678901234567890");
> let exp = BigInt("12345678901234567890");
> let mod = BigInt("987654321098765432109876543210987654321");
> 
> let encrypted = constantTimeModExp(base, exp, mod);
> console.log(encrypted.toString());
> ```
>
> 以上代码示例演示了如何在涉及 `BigInt` 的加密操作中使用恒定时间的运算方法。确保所有操作不依赖于输入数据的特定模式，从而有效地防止时序攻击。

`BigInt`字面量写作一串数字后跟小写字母`n`。默认情况下，基数是10，但可以通过前缀`0b`、`0o`和`0x`来表示二进制、八进制和十六进制`BigInt`：

```js
1234n  // 一个不太大的BigInt字面量
0b111111n // 二进制BigInt
0o7777n  // 八进制BigInt
0x8000000000000000n  // =>2n**63n：一个64位整数
```

可以用`BigInt()`函数把常规 JavaScript 数值或字符串转换为`BigInt`值：

```js
BigInt(Number.MAX_SAFE_INTEGER) // => 9007199254740991n
let string = "1" + "0".repeat(100); //1后跟100个零
BigInt(string) // => 10n**100n：一个天文数字
```

`BigInt`值的算术运算与常规JavaScript数值的算术运算类似，只不过除法会丢弃余数并且会向下（向零）舍入：

```js
1000n + 2000n //=>3000n
3000n-2000n // =>1000n
2000n * 3000n // => 6000000n
3000n / 997n //=>3n：商是3
3000n % 997n // => 9n：余数是9
(2n ** 131071n) - 1n // 有39457位数字的梅森素数
```

虽然标准的`+`、`-`、`*`、`/`、`%`和`**`操作符可以用于`BigInt`，但不能混用 `BigInt`操作数和常规数值操作数。乍一看这个规则有点奇怪，但实际上是合理的。如果一种数值类型比另一种更通用，则比较容易定义混合操作数的计算并返回更通用的类型。但上述两种类型都不比另一种更通用：BigInt可以表示超大值，因此它比常规数值更通用。但BigInt只能表示整数，这样看常规JavaScript数值类型反而更通用。这个问题无论如何也解决不了，因此JavaScript搁置了这个问题，只是简单地不允许在使用算术操作符时混用这两种类型的操作数。

相对来说，比较操作符允许混合操作数类型（关于`==`和`===`的区别，可以参考3.9.1节)：

```js
1 < 2n // => true
2 > 1n // =>true
0 == 0n // => true
0 === 0n //=>false：===也检查类型是否相等
```

位操作符（4.8.3节介绍）通常可以用于`BigInt`操作数。但`Math`对象的任何函数都不接收`BigInt`操作数。

> 在 JavaScript 中，`BigInt` 和常规数值（`Number`）是两个不同的数据类型，不能直接混用。这种设计决策带来了一些明显的弊端，尤其是在需要处理大数值并与常规数值进行混合计算的场景中。以下是一些具体的弊端：
>
> ### 1. 增加代码复杂性
>
> 由于 `BigInt` 和 `Number` 不能直接混用，在需要进行混合计算时，开发者必须显式地转换类型。这增加了代码的复杂性和维护成本。
>
> ```javascript
> let bigIntValue = BigInt(12345678901234567890n);
> let numberValue = 42;
> 
> // 无法直接混用
> let sum = bigIntValue + numberValue; // 会抛出错误
> 
> // 需要进行显式转换
> let sum = bigIntValue + BigInt(numberValue); // 或者
> let sum = Number(bigIntValue) + numberValue;
> ```
>
> ### 2. 性能开销
>
> 频繁的类型转换会带来性能开销，尤其是在大量数据处理的场景中。每次转换都需要额外的计算资源，这对性能敏感的应用尤其不利。
>
> ```javascript
> let bigIntValue = BigInt(12345678901234567890n);
> let numberArray = [1, 2, 3, 4, 5];
> let bigIntArray = numberArray.map(num => BigInt(num));
> ```
>
> ### 3. 增加出错概率
>
> 开发者在处理混合类型时容易出错，特别是在忘记进行必要的类型转换时。这样的错误可能导致程序崩溃或者产生意外的结果。
>
> ```javascript
> let bigIntValue = BigInt(12345678901234567890n);
> let numberValue = 42;
> 
> try {
>   let result = bigIntValue + numberValue;
> } catch (e) {
>   console.error("类型错误:", e);
> }
> ```
>
> ### 4. 不便于使用标准库
>
> 很多 JavaScript 的标准库和第三方库在设计时并没有考虑到 `BigInt`，这使得在与这些库交互时需要额外的处理逻辑。
>
> ```javascript
> let bigIntValue = BigInt(12345678901234567890n);
> let numberArray = [1, 2, 3, 4, 5];
> 
> // 需要转换以便与标准库函数一起使用
> let maxNumber = Math.max(...numberArray);
> let maxBigInt = BigInt(Math.max(...numberArray));
> ```
>
> ### 5. 限制运算操作
>
> 由于不能直接混用 `BigInt` 和 `Number`，某些运算操作会受到限制，需要特殊处理。
>
> ```javascript
> let bigIntValue = BigInt(12345678901234567890n);
> let numberValue = 42;
> 
> // 需要手动处理类型转换
> let divisionResult = bigIntValue / BigInt(numberValue); // 或者转换为Number后再操作
> let divisionResult = Number(bigIntValue) / numberValue;
> ```
>
> ### 解决方案与建议
>
> 1. **一致使用一种数值类型**：在设计系统时，尽可能一致地使用一种数值类型。如果确定需要处理大数值，优先使用 `BigInt`，并在整个系统中保持一致。
> 2. **封装转换逻辑**：将 `BigInt` 和 `Number` 的转换封装在函数中，减少重复的转换代码。
>    ```javascript
>    function toBigInt(value) {
>      return typeof value === 'bigint' ? value : BigInt(value);
>    }
>       
>    function toNumber(value) {
>      return typeof value === 'number' ? value : Number(value);
>    }
>    ```
> 3. **使用库支持**：寻找或使用支持 `BigInt` 的库，避免自己处理复杂的转换逻辑。
>
> 总结来说，`BigInt` 和 `Number` 不能直接混用确实带来了一些不便和复杂性，但通过良好的编码习惯和适当的工具支持，可以有效地管理和减轻这些弊端。

### 2.6 日期和时间

JavaScript 为表示和操作与日期及时间相关的数据而定义了简单的`Date`类。JavaScript 的`Date`是对象，但也有数值表示形式，即自1970年1月1日起至今的毫秒数，也叫时间戳：

```js
let timestamp = Date.now(); //当前时间的时间戳（数值）
let now = new Date(); //当前时间的日期对象
let ms = now.getTime();//转换为毫秒时间戳
let iso = now.toISoString(); //转换为标准格式的字符串
```

`Date`类及其方法在 11.4 节有详细介绍。但在 3.9.3 节探讨 JavaScript 类型转换时，我们也会提到`Date` 对象。

> 时间戳从 1970 年 1 月 1 日开始计算是为了与 Unix 时间标准保持一致。这个时间标准被称为“Unix 时间”或“Unix 纪元”，其初衷和设计考虑如下：
>
> ### 历史背景和起源
>
> 1. **Unix 操作系统的起源**：
>    Unix 操作系统最早在 1960 年代末和 1970 年代初开发。当时的计算机硬件和软件环境相对简单，设计一个统一的时间表示系统非常重要。Unix 纪元选择了 1970 年 1 月 1 日 00:00:00 UTC 作为时间的起点，这被称为“Unix 纪元”（Unix Epoch）。
>
> 2. **计算和表示的方便性**：
>    1970 年 1 月 1 日是一个相对现代的日期，选择这个日期可以减少计算和表示时间的复杂性。例如，年份较大（比如 1900 年以前）可能会导致日期计算的复杂性增加，而选择一个较新的起点可以避免这些问题。
>
> ### 技术原因和优势
>
> 1. **简化时间计算**：
>    使用一个固定的起点（1970 年 1 月 1 日）来表示时间，使得计算时间差变得非常简单。时间戳表示从这个起点开始经过的秒数，因此计算两个时间点之间的差异只需简单的减法运算。
>
> 2. **跨平台和跨语言的一致性**：
>    Unix 时间已经成为许多操作系统和编程语言的标准，选择一个统一的起点有助于不同系统和语言之间的一致性和兼容性。许多编程语言（如 C、Python、JavaScript 等）都采用了 Unix 时间标准。
>
> 3. **避免时区和夏令时问题**：
>    Unix 时间使用的是 UTC 时间，不受时区和夏令时变化的影响。这简化了时间处理，尤其是在需要跨时区计算时。
>
> ### Unix 时间戳的使用
>
> Unix 时间戳是指从 1970 年 1 月 1 日 00:00:00 UTC 开始到当前时间所经过的秒数。这个时间戳可以是正数或负数，以涵盖 Unix 纪元前后的时间。
>
> ```javascript
> // JavaScript 获取当前 Unix 时间戳
> let timestamp = Math.floor(Date.now() / 1000);
> console.log(timestamp);
> 
> // Python 获取当前 Unix 时间戳
> import time
> timestamp = int(time.time())
> print(timestamp)
> ```
>
> ### 示例
>
> 举个具体的例子，2024 年 5 月 20 日 00:00:00 UTC 的 Unix 时间戳计算如下：
>
> ```plaintext
> 2024 年 5 月 20 日 - 1970 年 1 月 1 日 = 54 年 4 个月 19 天
> = 54 * 365 + 13（闰年） + 31 + 29 + 31 + 20
> = 19724 + 13 + 31 + 29 + 31 + 20
> = 19848 天
> 
> 转换为秒：
> 19848 天 * 24 小时/天 * 3600 秒/小时
> = 1713984000 秒
> ```
>
> 因此，2024 年 5 月 20 日 00:00:00 UTC 的 Unix 时间戳是 1713984000。
>
> 总之，Unix 时间戳从 1970 年 1 月 1 日开始计算，是出于历史原因和技术上的便利性考虑。这一选择帮助简化了时间计算，并促进了跨平台和跨语言的一致性，使其成为现代计算机系统中广泛使用的时间标准。

## 3 文本

JavaScript 中表示文本的类型是`String`，即字符串。字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。字符串的`length`属性是它包含的16位值的个数。JavaScript 的字符串（以及数组）使用基于零的索引，因此第一个16位值的索引是0，第二个值的索引是1，以此类推。空字符串是长度为0的字符串。JavaScript没有表示单个字符串元素的专门类型。要表示一个16位值，使用长度为1的字符串即可。

> JavaScript 使用 Unicode 字符集的 UTF-16 编码，因此 JavaScript 字符串是无符号16位值的序列。最常用的Unicode字符（即“基本多语言平面”中的字符）的码点（codepoint）是16位的，可以用字符串中的一个元素来表示。码点超出16位的Unicode字符使用UTF-16规则编码为两个16位值的序列（称为 surrogate pair，即“代理对”）。这意味着一个长度为2（两个16位值）的JavaScript字符串可能表示的只是一个Unicode字符：
>
> ```js
> let euro = "€";
> let love = "❤️";
> 
> euro.length  // => 1: 这个字符是一个 16 位的元素
> love.length  // => 2: ❤️ 的 UTF-16 编码是 "\ud83d\udc99"
> ```
>
> JavaScript 的字符串操作方法一般操作的是16位值，而不是字符。换句话说，它们不会特殊对待代理对，不对字符串进行归一化，甚至不保证字符串是格式正确的UTF-16。
>
> 但在ES6中，字符串是可迭代的，如果对字符串使用`for/of`循环或`...`操作符，选代的是字符而不是16位值。
>
> ```js
> let love = "❤️";
> 
> // 使用 Array.from
> console.log(Array.from(love).length);  // 输出: 1
> 
> // 使用 [...string]
> console.log([...love].length);  // 输出: 1
> 
> // 使用 for...of 循环
> let count = 0;
> for (let char of love) {
>   count++;
> }
> console.log(count);  // 输出: 1
> ```

### 3.1 字符串字面量

要在 JavaScript 程序中包含字符串，可以把字符串放到一对匹配的单引号、双引号或者反引号（`'`、`"`或`` ` ``）中。双引号字符和反引号可以出现在由单引号定界的字符串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。下面是几个字符串字面量的例子：

```js
"" //空字符串，即有零个字符
"testing"
"3.14"
'name="myform"'
"Wouldn't you prefer O'Reilly's book?"
"π is the ratio of a circle's circumference to its radius"
`"She said 'hi'", he said.`
```

使用反引号定界字符串是ES6的特性，允许在字符串字面量中包含（或插入）JavaScript 表达式。3.3.4 节将介绍这种表达式插值语法。

JavaScript 最早的版本要求字符串字面量必须写在一行，使用+操作符把单行字符串拼接成长字符串的JavaScript代码随处可见。到了ES5，我们可以在每行末尾加一个反斜杠（`\`）从而把字符串字面量写到多行上。这个反斜杠和它后面的行终结符`\n`都不属于字符串字面量。如果需要在单引号或双引号字符串中包含换行符，需要使用字符序列`\n`（下一节讲述）。ES6的反引号语法支持跨行字符串，而行终结符`\n`也是字符串字面量的一部分：

```js
// 写在一行但表示两行的字符串：
'two\nlines'

// 写在三行但只有一行的字符串：
"one\
long\
line"

// 写在两行实际也是两行的字符串：
`the newline character at the end of this line
is included literally in this string`
```

注意，在使用单引号定界字符串时，必须注意英文中的缩写和所有格，比如 can't 和 O'Reilly 中的单引号。因为这里的撇号就是单引号，所以必须使用反斜杠字符（`\`）“转义”单引号中出现的所有撇号（下一节讲解转义）。

在客户端 JavaScript 编程中，JavaScript 代码中可能包含 HTML 代码的字符串，而 HTML 代码中也可能包含 JavaScript 代码。与 JavaScript 类似，HTML使用单引号或双引号来定界字符串。为此，如果要将JavaScript和HTML代码混合在一起，最好JavaScript和HTML分别使用不同的引号。在下面的例子中，JavaScript 表达式中的字符串“Thankyou”使用了单引号，而HTML事件处理程序属性则使用了双引号：

```html
<button onclick="alert('Thank you')">Click Me</button>
```

