# 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。

你将会学习一些实践技巧：

1. 如何避免由计算机表示数字的方式引起的奇怪的数字错误。
2. 怎样通过一些小窍门来优化自已的C代码，以充分利用现代处理器和存储器系统的设计。
3. 了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。
4. 如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。
5. 如何编写自己的Unixshell、自己的动态存储分配包，甚至于自己的Web服务器。
6. 认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。

我们通过跟踪hello程序的生命周期来开始对系统的学习一一从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。

`code/intro/hello.c`

```c
#include<stdio.h>

int main() {
    printf("hello,world\n");
    return 0;
}
```



## 1 信息就是位+上下文

hello程序的生命周期是从一个源程序（或者说源文件)开始的，即程序员通过编辑器创建并保存的文本文件，文件名是hello.c。**源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。**

大部分的现代计算机系统都使用**ASCII标准**来表示文本字符，这种方式实际上就是**用一个唯一的单字节大小的整数值来表示每个字符**。比如，图1-2中给出了hello.c程序的ASCII码表示。

![image-20240423233012808](https://blog-wjw.oss-cn-hangzhou.aliyuncs.com/blog/image-20240423233012808.png)

hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是35，它对应的就是字符“#”。第二个字节的整数值为105，它对应的字符是‘i”，依此类推。注意，每个文本行都是以一个看不见的换行符‘\n’来结束的，它所对应的整数值为10。像 hello.c 这样**只由ASCⅡI字符构成的文件称为文本文件，所有其他文件都称为二进制文件**。

hello.c 的表示方法说明了一个基本思想：**系统中所有的信息一一包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。**

作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。**它们是对真值的有限近似值**，有时候会有意想不到的行为表现。



## 2 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```shell
 gcc -o hello hello.c
```

在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件he11o。这个翻译过程可分为四个阶段完成，如图1-3所示。执行这四个阶段的程序（**预处理器、编译器、汇编器和链接器**）一起构成了**编译系统（compilation system）**。

![image-20240423235216808](https://blog-wjw.oss-cn-hangzhou.aliyuncs.com/blog/image-20240423235216808.png)

* **预处理阶段**。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的`#include<stdio.h>`命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插人程序文本中。结果就得到了另一个C程序，通常是以 .i 作为文件扩展名。

* **编译阶段**。编译器（ccl) 将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：

  ```assembly
  main:
  	subq    $8, %rsp
  	movl    $.LCO，%edi
  	call    puts
  	movl    $0, %eax
  	addq    $8, %rsp
  	ret
  ```

  定义中2～7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

* **汇编阶段**。接下来，汇编器（as) 将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program)的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

* **链接阶段**。请注意，hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld) 就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。

> GCC是GNU（GNU是GNU's Not Unix的缩写）项目开发出来的众多有用工具之一。GNU项目是1984年由RichardStallman发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类Unix的系统，其源代码能够不受限制地被修改和传播。GNU项目已经开发出了一个包含Unix操作系统的所有主要部件的环境，但内核除外，内核是由Linux项目独立发展而来的。GNU环境包括EMACS编辑器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括C、C++、Fortran、Java、Pascal、面向对象C语言（Objective-C)和Ada。
>
> GNU项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动（通常和Linux联系在一起）的思想起源是GNU项目中自由软件（freesoftware）的概念。（此处的free为自由言论（free speech)中的“自由”之意，而非免费啤酒（freebeer）中的“免费”之意。）而且，Linux如此受欢迎在很大程度上还要归功于GNU工具，它们给Linux内核提供了环境。
>
> 

## 3 了解编译系统如何工作是大有益处的

对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。

* **优化程序性能。**现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在C程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。比如：
  * 一个switch语句是否总是比一系列的if-else语句高效得多？
  * 一个函数调用的开销有多大？
  * while循环比for循环更有效吗？
  * 指针引用比数组索引更有效吗？
  * 为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？
  * 为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？
* **理解链接时出现的错误。**根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现。
* **避免安全漏洞。**多年来，缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。



## 4 处理器读并解释存储在内存中的指令

此刻，hello.c源程序已经被编译系统翻译成了可执行目标文件hello，并被存放在磁盘上。要想在Unix系统上运行该可执行文件，我们将它的文件名输人到称为shell的应用程序中：

![image-20240425194638331](https://blog-wjw.oss-cn-hangzhou.aliyuncs.com/blog/image-20240425194638331.png)

shell是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell将加载并运行hello程序，然后等待程序终止。hello程序在屏幕上输出它的消息，然后终止。shell随后输出一个提示符，等待下一个输人的命令行。

### 4.1 系统的硬件组成

为了理解运行hello程序时发生了什么，我们需要了解一个典型系统的硬件组织，如图1-4所示。这张图是近期Intel系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂一一我们将在本书分阶段对其进行详尽的介绍。

![image-20240425220530108](https://blog-wjw.oss-cn-hangzhou.aliyuncs.com/blog/image-20240425220530108.png)



## 5 高速缓存至关重要



## 6 存储设备形成层次结构



## 7 操作系统管理硬件



## 8 系统之间利用网络通信



## 9 重要主题



## 10 小结